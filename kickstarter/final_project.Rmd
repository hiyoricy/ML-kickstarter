---
title: "[CATCHY TITLE]"
author:
- Hoyt Gong
- Younghu Park
- Hiyori Yoshida
output:
  pdf_document:
    toc: yes
    toc_depth: '4'
  html_document:
    code_folding: show
    highlight: haddock
    theme: lumen
    toc: yes
    toc_depth: 4
    toc_float: yes
  word_document:
    toc: yes
    toc_depth: '4'
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.height=4, fig.width=6, warning = F)
if (!require("pacman")) install.packages("pacman")
pacman::p_load(dplyr, ggplot2, tidyverse, jsonlite, lubridate, zoo)

```

# Summary 

# Description of the Problem

First, some terms are defined to help explain how Kickstarter works. 

A **creator** is the person or team behind a project idea. 

A **project** is a finite work with a clear goal for which a creator is seeking funding.

The **funding goal** is the amount of money that a creator seeks to raise for their project. 

**Backers** are people who **pledge** money to help creators make their projects a reality. 

Creators who seek funding on Kickstarter want their projects to succeed so they can bring their ideas to life. Funding on Kickstarter is all-or-nothing. This means the creator will not receive the money people have pledged toward their project unless the project reaches its funding goal. Thus, "success" in this case is reaching the funding goal. As demonstrated in Kickstarter's [Creator Handbook](https://www.kickstarter.com/help/handbook?ref=whatarebasics), creators put a lot of effort into designing their project, funding, promotion, and communication to increase their chances of reaching their funding goal. 

The goal of this paper is to use attributes of existing Kickstarter projects in classifiers to predict whether a project will succeed or fail. Determining the atrributes of a project that are most valuable in predicting success can help creators design their projects to maximize their chances of reaching their funding goal. 

# Description of the Data

[Web Robots](https://webrobots.io/kickstarter-datasets/) has been scraping data from Kickstarter projects monthly starting March 2016. The most recent data from November 2019 is used in this project. The response variable that is predicted in this project is `state`, a categorical variable that is either "successful" or "failed". The original data includes "canceled" as a state, which are converted to "failed". This is because it is assumed that canceled projects would likely have failed. The following independent variables are considered in the analysis: 

|Independent Variable|Description|
|-----------------|--------------------------------|
| `backers_count` | The number of backers that have pledged some amount of money to the project. |
| `blurb` | A short description at the top of project pages that describe/promote the project. |
| `category` | The category of the project. There are TODO??? total categories in the dataset, including "public Art," "software," "narrative film," etc. |
| `converted_pledged_amount` | The amount pledged to the project in USD. |
| `country` | The country in which the project is based. | 
| `location` | The city and state in wich the project is based. |
| `deadline` | The date and time (???) of the deadline until which the project will raise funds. After the deadline, the project is determined to be "successful" or "failed" depending on whether it reached its funding goal. |
| `launched_at` | The date and time (???) at which the project was made public and started raising funds. |
| `duration` | deadline - launched_at. The fundraising duration of the project. |
| `goal` | The funding goal of the project. |
| `name` | The title of the project. |
| `usd_pledged` | The amount pledged towards the project in USD. |
| `staff_pick` | True if the Kickstarter staff have chosen to feature the project in their "Projects We Love" program, false otherwise. |

# Data Cleaning and Preparation

```{r}
#function to merge csv files and write to one dataset

#multMerge = function(mypath){
#  filenames = list.files(path = mypath, full.names = TRUE)
#  datalist = lapply(filenames, 
#                    function(x){read.csv(file = x,
#                                         header = TRUE,
#                                         stringsAsFactors = FALSE)})
#  Reduce(function(x,y) {merge(x, y, all = TRUE)}, datalist)
#}

#my_data <- multMerge("Kickstarter_2019-11-14T03_20_27_004Z")

#mydata <- my_data %>% unique() #unique columns

#write.csv(my_data,"kick_data.csv", row.names = TRUE)
```

```{r}
#to import dataset
kick_data <- read.csv("kick_data.csv", header=TRUE)
```

```{r}
head(kick_data)
```

```{r}
dim(kick_data)
```

```{r}
colnames(kick_data)
```

```{r}
#initial deletion of columns
to_remove <- c("X.1", "creator", "currency_symbol", "currency_trailing_code", "current_currency", "disable_communication", "friends", "fx_rate", "is_backing", "permissions", "photo", "profile","source_url", "static_usd_rate","urls")
kick_data <- kick_data %>% select(-to_remove)

```


```{r}
#filtering out additional duplicates, keeping max state
kick_data <- kick_data %>% group_by(id)%>% filter(state_changed_at == max(state_changed_at)) %>% filter(X == max(X)) %>% rename(sub_id=X)
```


```{r}
#converting created_at, state_changed_at to datetime formats
dts <- kick_data$created_at
mydates = dts
class(mydates) = c('POSIXt','POSIXct')
kick_data$created_at <- as.Date(mydates)

dts <- kick_data$state_changed_at
mydates = dts
class(mydates) = c('POSIXt','POSIXct')
kick_data$state_changed_at <-  as.Date(mydates)

dts <- kick_data$launched_at
mydates = dts
class(mydates) = c('POSIXt','POSIXct')
kick_data$launched_at <- as.Date(mydates)

dts <- kick_data$deadline
mydates = dts
class(mydates) = c('POSIXt','POSIXct')
kick_data$deadline <-  as.Date(mydates)
```

```{r}
#parsing our json data to extract categories 
ParseJSONColumn <- function(x)  {
     str_c("[ ", str_c(x, collapse = ",", sep=" "), " ]") %>% 
      fromJSON(flatten = T) %>% 
     as.tibble()
} 

JSONcolumn_data <- kick_data  %>% 
    select(id, category)  %>% 
    map_dfc(.f = ParseJSONColumn)  %>% select(value, name, slug) %>% rename(id = value, category = name, subcategory = slug)


kick_data.f <- kick_data %>% select(-category) %>% rename(description=slug)

kick_data.f <-  merge(kick_data.f, JSONcolumn_data ,by="id")

```

```{r}
#extracting locations through string splits
parsed_location <- kick_data.f %>% separate(location, c("foo", "bar"), '\"displayable_name\":\"') %>% select(foo,bar) %>% separate(bar, c("location", "foo2"), '\",\"') %>% select(location)

kick_data.f$location <- parsed_location$location
```


```{r}
#filtering out the live projects
kick_data.live <- kick_data.f %>% filter(state=="live")
kick_data.f <- kick_data.f %>% filter(state != "live")
```


```{r}
#creating predictor column
kick_data.f$successful<- as.factor(ifelse(kick_data.f$state=="successful", 1, 0))
```


```{r}
#converting types of columns
kick_data.f$location <- as.factor(kick_data.f$location)
kick_data.f$blurb <- as.character(kick_data.f$blurb)
kick_data.f$description <- as.character(kick_data.f$description)
```

```{r}
#final state
str(kick_data.f)
```

# Model Overview

# Models

## Logistic Regression

## Random Forest

# Comparison of Methods 

# Final Model 

# Validity of Results and Future Improvement

# Conclusion

# Appendix

# Works Cited

